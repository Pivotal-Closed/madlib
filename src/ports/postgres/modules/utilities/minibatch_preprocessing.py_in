# coding=utf-8
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.


"""
@file minibatch_preprocessing.py_in

"""
import plpy
from utilities import unique_string
from utilities import split_quoted_delimited_str
from utilities import validate_module_input_params
from utilities import _assert
from validate_args import get_expr_type

m4_changequote(`<!', `!>')

class MinibatchPreProcessor:
    def __init__(self, schema_madlib, source_table, output_table,
                 independent_varname, dependent_varname, n_elements, **kwargs):

        self.schema_madlib = schema_madlib
        self.source_table = source_table
        self.output_table = output_table
        self.independent_varname = independent_varname
        self.dependent_varname = dependent_varname
        self.n_elements = n_elements
        self.module_name = "minibatch_preprocessor"

    def minibatch_preprocessor(self):
        """

        :param schema_madlib:
        :param source_table:
        :param output_table:
        :param independent_varname:
        :param dependent_varname:
        :param n_elements:
        :param kwargs:
        :return:
        """
        self.validate_minibatch_preprocessor_params()

        query_formatter = MinibatchQueryFormatter(self.source_table)
        indep_var_array_str = query_formatter.get_indep_var_array_str(self.independent_varname)
        dep_var_array_str = query_formatter.get_dep_var_array_str(self.dependent_varname)

        uq_id = "id"
        uq_dep = "dependent_varname"
        uq_ind = "independent_varname"
        uq_tbl = unique_string("tbl")

        sql = """
            CREATE TABLE {output_table} AS
            SELECT {uq_id},
                   {schema_madlib}.matrix_agg({uq_ind}) as {uq_ind},
                   {schema_madlib}.matrix_agg({uq_dep}) as {uq_dep}
            FROM (
                SELECT (row_number() OVER (ORDER BY random()) - 1) / {n_elements}
                            as {uq_id},
                        {indep_var_array_str} as {uq_ind},
                        {dep_var_array_str} as {uq_dep}
                FROM
                    {source_table}
            ) {uq_tbl}
            GROUP BY {uq_id}
            """.format(
            schema_madlib=self.schema_madlib,
            source_table=self.source_table,
            output_table=self.output_table,
            n_elements=self.n_elements,
            **locals())
        plpy.execute(sql)


    def validate_minibatch_preprocessor_params(self):

        validate_module_input_params(self.source_table, self.output_table,
                                     self.independent_varname, self.dependent_varname,
                                     self.module_name)

        _assert(self.n_elements>0, "minibatch_preprocessor: The buffer size has to be a"
                              " positive integer.")

class MinibatchQueryFormatter:
    def __init__(self, source_table):
        self.source_table = source_table

    def get_indep_var_array_str(self, independent_varname):
        array_features = []
        non_array_features = []
        feature_list = split_quoted_delimited_str(independent_varname)
        for feat in feature_list:
            feat_type = get_expr_type(feat, self.source_table)
            if '[]' in feat_type:
                array_features.append(feat)
            else:
                non_array_features.append(feat)
        indep_var_array_str = ("ARRAY[{0}]::double precision[]".
                               format(', '.join(non_array_features)))
        for each_array_feat in array_features:
            indep_var_array_str = ('ARRAY_CAT({0}, {1})'.
                                   format(each_array_feat, indep_var_array_str))
        return indep_var_array_str


    def get_dep_var_array_str(self, dependent_varname):
        """
        If not encoding (test if the input is a numeric value):
            1. dependent_varname = rings
                output = ARRAY[[rings1], [rings2], []]
            2. dependent_varname = ARRAY[a, b, c]
                output = ARRAY[[a1, b1, c1], [a2, b2, c2], []]
        If encoding:
            3. dependent_varname = rings (encoding)
                output = ARRAY[[rings1=1, rings1=2], [rings2=1, rings2=2], []]
        """
        dep_type = get_expr_type(dependent_varname, self.source_table)
        if dep_type in ("text", "boolean"):
            # for encoding
            dep_level_sql = """
                    SELECT DISTINCT {dependent_varname} AS class
                    FROM {source_table}
                """.format(dependent_varname=dependent_varname,
                           source_table=self.source_table)
            dep_levels = plpy.execute(dep_level_sql)

            # this is string sorting
            classes = sorted(["'{0}'".format(l["class"]) for l in dep_levels])
            one_hot_dep_list = []
            for c in classes:
                one_hot_dep_list.append("{0} = {1}".format(dependent_varname, c))
            dep_var_array_str = 'ARRAY[{0}]::integer[]'.format(
                ','.join(one_hot_dep_list))
        elif "[]" in dep_type:
            dep_var_array_str = dependent_varname
        else:
            dep_var_array_str = 'ARRAY[{0}]'.format(dependent_varname)

        return dep_var_array_str
# ---------------------------------------------------------------------
